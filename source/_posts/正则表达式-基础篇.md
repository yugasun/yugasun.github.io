---
title: 正则表达式(基础篇)
reward: true
date: 2017-04-24 15:16:01
tags: 正则表达式
---

> 典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，虽然不是不可能，但是至少也会变得很困难。

## 为什么使用正则表达式？

使用正则表达式可以很好地解决以上痛点，因为正则表达式可以：

* **测试字符串内的模式**: 查看字符串内是否出现电话号码模式或信用卡号码模式 - 数据验证。
* **替换文本**: 识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
* **基于模式匹配从字符串中提取子字符串**: 查找文档内或输入域内特定的文本。

<!-- more -->

## 基本语法

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合.


### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

<style>
table th:first-of-type {
  min-width: 100px;
}
</style>

| 字符    | 描述
| :----: | ----------------
| \d	   |   匹配一个数字字符。等价于 `[0-9]`。
| \D	   |   匹配一个非数字字符。等价于 `[^0-9]`。
| \w	   |   匹配包括下划线的任何单词字符。等价于 `[A-Za-z0-9_]`。
| \W	   |   匹配任何非单词字符。等价于 `[^A-Za-z0-9_]`。


### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符     |   描述
| :-------: | ----------------------------------------------------------------------------------------------------
| \cx     |  匹配由x指明的控制字符。
| \f      |  匹配一个换页符。等价于 `\x0c` 和 `\cL`。
| \n      |  匹配一个换行符。等价于 `\x0a` 和 `\cJ`。
| \r      |  匹配一个回车符。等价于 `\x0d` 和 `\cM`。
| \s      |  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。
| \S      |  匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。
| \t      |  匹配一个制表符。等价于 `\x09` 和 `\cI`。
| \v      |  匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`。


### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，列表如下：

|     字符  |	 描述
| :------: | --------------
| $	       | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 也匹配 `\n` 或 `\r`。要匹配 `$` 字符本身，请使用 `\$`。
| ( )	     |  标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。
| *	       |  匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。
| +	       |  匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\+`。
| .	       |  匹配除换行符 `\n` 之外的任何单字符。要匹配 `.` ，请使用 `\.` 。
| [	       |  标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。
| ?	       |  匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?`。
| \	       |  将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，`n` 匹配字符 `n`。`\n` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 `(`。
| ^	       | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 `^` 字符本身，请使用 `\^`。
| {	       | 标记限定符表达式的开始。要匹配 `{`，请使用 `\{`。
| &#124;	 | 指明两项之间的一个选择。要匹配 `&#124;`，请使用 `\&#124;`。


### 限定符

用来指定正则表达式的一个给定匹配组件必须要出现多少次，共6种：

|  字符	   | 描述
| :-----: | -------------
|  *	    |  匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 `z` 以及 `zoo`。`*` 等价于 `{0,}`。
|  +	    |  匹配前面的子表达式一次或多次。例如，`zo+` 能匹配 `zo` 以及 `zoo`，但不能匹配 `z`。`+` 等价于 `{1,}`。
|  ?	    |  匹配前面的子表达式零次或一次。例如，`do(es)?` 可以匹配 `do` 或 `does` 中的 `do` 。`?` 等价于 `{0,1}`。
|  {n}	  |  `n` 是一个非负整数。匹配确定的 `n` 次。例如，`o{2}` 不能匹配 `Bob` 中的 `o`，但是能匹配 `food` 中的两个 `o`。
|  {n,}   | 	`n` 是一个非负整数。至少匹配 `n` 次。例如，`o{2,}` 不能匹配 `Bob` 中的 `o`，但能匹配 `foooood` 中的所有 `o`。`o{1,}` 等价于 `o+`。`o{0,}` 则等价于 `o*`。
|  {n,m}  | 	`m` 和 `n` 均为非负整数，其中 `n <= m`。最少匹配 `n` 次且最多匹配 `m` 次。例如，`o{1,3}` 将匹配 `fooooood` 中的前三个 `o`。`o{0,1}` 等价于 `o?`。请注意在逗号和两个数之间不能有空格。


### 定位符

`定位符` 用来描述字符串或单词的边界，共4种：

|   字符	  | 描述
| :------: | -------------
|   ^	     |  匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，`^` 还会与 `\n` 或 `\r` 之后的位置匹配。
|   $	     |  匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，`$` 还会与 `\n` 或 `\r` 之前的位置匹配。
|   \b	   |  匹配一个字边界，即字与空格间的位置。
|   \B	   |  非字边界匹配。

> 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*` 之类的表达式。


### 非捕捉元字符

用圆括号将所有选择项括起来，相邻的选择项之间用 `|` 分隔。但用圆括号会有一个副作用，相关的匹配会被缓存，此时可以用 `?:` 放在第一个选项前来先出这种副作用。

| 字符     |  描述
| :-------: | --------------
| (?:x)	  |  匹配 `x` 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 `/(?:foo){1,2}/` 。如果表达式是 `/foo{1,2}/`，`{1,2}`将只对 `foo` 的最后一个字符 `o` 生效。如果使用非捕获括号，则 `{1,2}` 会匹配整个 `foo` 单词。
| x(?=y)	|  匹配 `x` 仅仅当 `x` 后面跟着 `y`.这种叫做正向肯定查找。<br /><br />  例如，`/Jack(?=Sprat)/` 会匹配到 `Jack` 仅仅当它后面跟着 `Sprat`。`/Jack(?=Sprat&#124;Frost)/` 匹配 `Jack` 仅仅当它后面跟着 `Sprat` 或者是 `Frost` 。但是 `Sprat` 和 `Frost` 都不是匹配结果的一部分。
| x(?!y)	|  匹配 `x` 仅仅当 `x` 后面不跟着 `y`,这个叫做正向否定查找。<br /><br />例如，`/\d+(?!\.)/` 匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式 `/\d+(?!\.)/.exec("3.141")` 匹配 `141` 但是不是 `3.141`


### 反向引用

对一个正则表达式模式或部分模式两边添加 `()` 将导致相关匹配存储到一个临时缓冲区中, 所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以用 `\n` 访问，其中 `n` 为一个表示特定缓冲区的位置。可以使用非捕获元来重写捕获，忽略对相关配的保存。

如：

```javascript
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/ig;
console.log(str.match(patt1)); // ["Is is", "of of", "up up"]
```

## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
相同优先级从左到右进行运算，不同优先级的运算从优先级高到低运算，下表为各种正则表达式运算优先级顺序：

| 运算符	                        | 描述
| :--------------------------- | -----------------------
| \	                            |   转义符
| (), (?:), (?=), []            | 	圆括号和方括号
| *, +, ?, {n}, {n,}, {n,m}     | 	限定符
| ^, $, \任何元字符、任何字符	     |   定位点和序列（即：位置和顺序）
| &#124;                        |   替换，"或"操作 <br/> 字符具有高于替换运算符的优先级，使得 **m&#124;food** 匹配 `m` 或 `food`。若要匹配 `mood` 或 `food`，请使用括号创建子表达式，从而产生 **(m&#124;f)ood**。


文章内容还有不完备的地方，但是对于 javascript 的使用已经足够，内容理论为主，建议按需消化，最好结合自己工作中碰到的相关案例来理解，比如jquery源码(v1.4.4)中非常经典的一个正则匹配 `/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/`

有关正则表达式在 JavaScript 中的应用，将在下一篇 `正则表达式(实践篇)` 中讲解。

## 相关文章

* [正则表达式 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
* [正则表达式 - 菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)